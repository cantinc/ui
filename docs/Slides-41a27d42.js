import{S as e,R as o,_ as s,e as l,F as r,a as n,o as a,a9 as t,s as c,ax as i}from"./docs-c7a99efa.js";const f=c(i);function*v(c){var{slides:i,vertical:v,value:d=new e(0),onchange:u,ref:p=new o,onscroll:h,slideProps:w}=c,g=s(c,["slides","vertical","value","onchange","ref","onscroll","slideProps"]);const m=f();let x=!1,y=!1;const I=new e(!1);u=l(d,u);for(const e of i)e.ref||(e.ref=new o);yield{type:r,props:{...g,ref:p,vertical:v,onscroll:e=>{x=!0,null==h||h(e)},class:()=>[m.root,v&&m.vertical,I.value&&m.ready]},children:[i.map((e=>{var{children:o}=e,l=s(e,["children"]);return{type:r,props:{...w,...l,class:()=>m.slide},children:[o]}}))]};const T=new IntersectionObserver((e=>{if(x)for(const o of e)if(o.isIntersecting){const e=i.findIndex((({ref:e})=>(null==e?void 0:e.value)===o.target));n(d)!==e&&(y=!0,null==u||u(e))}}),{root:null==p?void 0:p.value,rootMargin:"0px",threshold:1});a((()=>{T.disconnect()}));for(const e of i)T.observe(e.ref.value);new t((()=>{var e;const o=n(d);if(y)y=!1;else if(p.value){const s=p.value,l=i[o],r=null===(e=null==l?void 0:l.ref)||void 0===e?void 0:e.value;r&&s.scrollTo(r.offsetLeft,r.offsetTop)}})),setTimeout((()=>{I.value=!0}))}export{v as S};
